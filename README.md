
# about this project

the goal of this project is to demonstrate a few things
* An AppSync api can be defined independently of any resolving logic
* Root level graphQl fields can point to a lambda function for resolution
* NESTED graphQl fields can point to a different lambda resolver & they can use the result of the parent field to resolve their value
* A lambda function inside one STACK can be exported and pulled into another stack with Fn:Join syntax
* This allows us to plug and play bits of resolver logic within a parent graphQl Schema, opening possibilities for loosely coupled microservices to interact, and allowing none to get too big
* In this very simple example it doesn't make sense to have everything exist in seperate stacks. It just makes it cumbersome to deploy. It would make more sense to reference funtions in other stacks in a complicated project.

## !! not addressed here
the demo is not as efficient as it could be, the nested vendor field must wait for it's parent resolver to resolve so that it may use the result in it's execution

** however, technically we could fetch the vendor associated with a voucher at the same time because we already have the vendorID in most scenarios from the client side. 
A more optimized implementation would get the vendor data + voucher data in parallel rather than waiting the result of voucher() to complete 


# /api

## /infastructure

### appSyncApi.yml

* defines api endpoint
* points appSync to the schema.txt file
* defined exported cloud formation appSync resources

### permission.yml

defines IAM permissions for,
* lambda invocation
* logging

### ROOTresolvers.yml

where all root level resolvers are defined
* TypeName is Query to denote it as a root level query field
* The data source is a lambda function defined in another CF stack
* using Fn:ImportValue to pull in the arn 

### NESTEDresolvers.yml

* `TypeName: Voucher` tells appSync to look on the Voucher type defined in the schema.txt file for the field that this resolver resolves
* `RequestMappingTemplate` is different here, this field instead of needing to access the graphQl arguments must acces the result of it's parent's feild 
* The request mapping template passes the result of the parent resolver to this resolver 
* The lambda function reference is imported from another stack


# /vendor-resolver

### handler
* `vendors` is a mock data store
* based on graphQl args the correspodning vendor is returned 

### serverless.yml
* an Output is declared, this is so that we can refence this function in another stack
* VendorResolverLambdaFunction is the name generated by serverless i.e. `Lambda::Function	{normalizedFunctionName}LambdaFunction` see https://serverless.com/framework/docs/providers/aws/guide/resources
* We use `Fn::GetAtt:` psuedo parameter CF syntax to access the arn that will be generated as part of creating the stack
* Export.Name - gives us an convenient string we can use to reference this resource in other stacks  

# /voucher-resolver

### handler
* `vouchers` is a mock data store
*  based on graphQl args the correspodning voucher is returned 

### serverless.yml
* same idea as sls.yml in vendor-resolver
